<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Ian's Universal Image Resizer & Optimizer v1.0</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
                background: #f5f5f5;
            }
            
            .container {
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            }
            
            h1 {
                color: #333;
                text-align: center;
                margin-bottom: 30px;
            }
            
            .upload-area {
                border: 2px dashed #4CAF50;
                border-radius: 10px;
                padding: 40px;
                text-align: center;
                margin-bottom: 20px;
                background: #f9fff9;
                transition: all 0.3s ease;
            }
            
            .upload-area:hover {
                border-color: #45a049;
                background: #f0fff0;
            }
            
            .upload-area.dragover {
                border-color: #45a049;
                background: #e8f5e8;
            }
            
            input[type="file"] {
                display: none;
            }
            
            .upload-btn {
                background: #4CAF50;
                color: white;
                padding: 12px 24px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                transition: background 0.3s ease;
            }
            
            .upload-btn:hover {
                background: #45a049;
            }
            
            .process-btn {
                background: #2196F3;
                color: white;
                padding: 12px 24px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                margin: 10px 5px;
                display: none;
                transition: background 0.3s ease;
            }
            
            .process-btn:hover {
                background: #1976D2;
            }
            
            .process-btn:disabled {
                background: #ccc;
                cursor: not-allowed;
            }
            
            .download-btn {
                background: #FF9800;
                color: white;
                padding: 12px 24px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                margin: 10px 5px;
                transition: background 0.3s ease;
            }
            
            .download-btn:hover {
                background: #F57C00;
            }
            
            .status {
                margin-top: 20px;
                padding: 10px;
                border-radius: 5px;
                display: none;
            }
            
            .status.success {
                background: #d4edda;
                color: #155724;
                border: 1px solid #c3e6cb;
            }
            
            .status.error {
                background: #f8d7da;
                color: #721c24;
                border: 1px solid #f5c6cb;
            }
            
            .status.info {
                background: #d1ecf1;
                color: #0c5460;
                border: 1px solid #bee5eb;
            }
            
            .file-list {
                margin-top: 20px;
                max-height: 200px;
                overflow-y: auto;
                border: 1px solid #ddd;
                border-radius: 5px;
                padding: 10px;
                background: #fafafa;
            }
            
            .file-item {
                padding: 5px;
                border-bottom: 1px solid #eee;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .file-item:last-child {
                border-bottom: none;
            }
            
            .file-name {
                font-weight: bold;
                color: #333;
            }
            
            .file-size {
                color: #666;
                font-size: 14px;
            }
            
            .progress-bar {
                width: 100%;
                height: 20px;
                background: #f0f0f0;
                border-radius: 10px;
                overflow: hidden;
                margin-top: 10px;
                display: none;
            }
            
            .progress-fill {
                height: 100%;
                background: linear-gradient(90deg, #4CAF50, #45a049);
                width: 0%;
                transition: width 0.3s ease;
            }
            
            .download-area {
                margin-top: 20px;
                display: none;
            }
            
            .instructions {
                background: #e3f2fd;
                padding: 15px;
                border-radius: 5px;
                margin-bottom: 20px;
                border-left: 4px solid #2196F3;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Ian's Universal Image Resizer & Optimizer v1.0</h1>
            
            <div class="instructions">
                <strong>Instructions:</strong>
                <ul>
                    <li>Select up to 50 images (supports PNG, JPG, JPEG, WEBP, GIF, BMP)</li>
                    <li><strong>Resize Only:</strong> Resizes to 500px max dimension (keeps original format when possible)</li>
                    <li><strong>Compress Only:</strong> Compresses to ~50kB (converts to JPEG)</li>
                    <li><strong>Resize & Compress:</strong> Does both operations for optimal results</li>
                </ul>
                <div style="margin-top: 10px; font-size: 14px; color: #666;">
                    <strong>Supported formats:</strong> PNG, JPG/JPEG, WEBP, GIF, BMP<br>
                    <strong>Output formats:</strong> PNG (resize-only), JPEG (compress & optimize)<br>
                    <strong>Note:</strong> Original filenames are preserved
                </div>
            </div>
            
            <div class="upload-area" id="uploadArea">
                <p>Drag & drop images here or click to select</p>
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    Select Images
                </button>
                <input type="file" id="fileInput" accept=".png,.jpg,.jpeg,.webp,.gif,.bmp,image/*" multiple>
            </div>
            
            <div class="file-list" id="fileList" style="display: none;"></div>
            
            <div style="text-align: center;">
                <button class="process-btn" id="resizeBtn" style="background: #2196F3;">Resize Only</button>
                <button class="process-btn" id="compressBtn" style="background: #9C27B0;">Compress Only</button>
                <button class="process-btn" id="combineBtn" style="background: #4CAF50;">Resize & Compress</button>
            </div>
            
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="status" id="status"></div>
            
            <div class="download-area" id="downloadArea">
                <h3>Download Processed Images:</h3>
                <div id="downloadLinks"></div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script>
            let selectedFiles = [];
            let processedImages = [];

            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            const fileList = document.getElementById('fileList');
            const resizeBtn = document.getElementById('resizeBtn');
            const compressBtn = document.getElementById('compressBtn');
            const combineBtn = document.getElementById('combineBtn');
            const status = document.getElementById('status');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const downloadArea = document.getElementById('downloadArea');
            const downloadLinks = document.getElementById('downloadLinks');

            // Drag and drop functionality
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type.startsWith('image/')
                );
                handleFiles(files);
            });

            fileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                handleFiles(files);
            });

            function handleFiles(files) {
                // Filter to only accept supported image types
                const supportedTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/webp', 'image/gif', 'image/bmp'];
                const validFiles = files.filter(file => supportedTypes.includes(file.type));
                
                if (validFiles.length === 0) {
                    showStatus('Please select valid image files (PNG, JPG, JPEG, WEBP, GIF, BMP).', 'error');
                    return;
                }
                
                if (validFiles.length > 50) {
                    showStatus('Please select maximum 50 images.', 'error');
                    return;
                }

                selectedFiles = validFiles.slice(0, 50);
                displayFileList();
                resizeBtn.style.display = 'inline-block';
                compressBtn.style.display = 'inline-block';
                combineBtn.style.display = 'inline-block';
                showStatus(`${selectedFiles.length} images selected.`, 'info');
            }

            function displayFileList() {
                fileList.innerHTML = '';
                fileList.style.display = 'block';

                selectedFiles.forEach((file, index) => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    const fileType = file.type.split('/')[1].toUpperCase();
                    fileItem.innerHTML = `
                        <div>
                            <div class="file-name">${file.name}</div>
                            <div class="file-size">${(file.size / 1024 / 1024).toFixed(2)} MB â€¢ ${fileType}</div>
                        </div>
                    `;
                    fileList.appendChild(fileItem);
                });
            }

            function showStatus(message, type) {
                status.textContent = message;
                status.className = `status ${type}`;
                status.style.display = 'block';
            }

            function updateProgress(percent) {
                progressFill.style.width = percent + '%';
            }

            function getOutputFilename(originalName, originalType, mode) {
                // For resize-only mode, try to keep original format and filename
                if (mode === 'resize') {
                    if (originalType === 'image/jpeg' || originalType === 'image/jpg' || 
                        originalType === 'image/png' || originalType === 'image/webp') {
                        return originalName; // Keep original name and format
                    } else {
                        // Convert GIF/BMP to PNG but keep original name structure
                        return originalName.replace(/\.(gif|bmp)$/i, '.png');
                    }
                } else {
                    // For compress and optimize modes, convert to JPEG but keep original base name
                    return originalName.replace(/\.(png|jpg|jpeg|webp|gif|bmp)$/i, '.jpg');
                }
            }

            function getOutputFormat(originalType, mode) {
                if (mode === 'resize') {
                    if (originalType === 'image/jpeg' || originalType === 'image/jpg') {
                        return 'image/jpeg';
                    } else if (originalType === 'image/png') {
                        return 'image/png';
                    } else if (originalType === 'image/webp') {
                        return 'image/webp';
                    } else {
                        return 'image/png'; // Convert GIF/BMP to PNG
                    }
                } else {
                    return 'image/jpeg'; // Always JPEG for compress/optimize
                }
            }

            function resizeOnlyImage(file, maxSize = 500) {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = function() {
                        // Calculate new dimensions
                        let { width, height } = img;
                        const originalWidth = width;
                        const originalHeight = height;
                        
                        if (width > height) {
                            if (width > maxSize) {
                                height = (height * maxSize) / width;
                                width = maxSize;
                            }
                        } else {
                            if (height > maxSize) {
                                width = (width * maxSize) / height;
                                height = maxSize;
                            }
                        }
                        
                        // Set canvas dimensions
                        canvas.width = width;
                        canvas.height = height;
                        
                        // Determine output format and filename
                        const outputFormat = getOutputFormat(file.type, 'resize');
                        const newFileName = getOutputFilename(file.name, file.type, 'resize');
                        
                        // For JPEG output, fill with white background to avoid black
                        if (outputFormat === 'image/jpeg') {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, width, height);
                        }
                        
                        // Draw and resize image
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // Convert to blob
                        canvas.toBlob((blob) => {
                            resolve({
                                blob: blob,
                                name: newFileName,
                                originalSize: file.size,
                                newSize: blob.size,
                                width: width,
                                height: height,
                                originalFormat: file.type,
                                newFormat: outputFormat,
                                resizedFromOriginal: width !== originalWidth || height !== originalHeight,
                                compressionRatio: ((file.size - blob.size) / file.size * 100).toFixed(1)
                            });
                        }, outputFormat, outputFormat === 'image/jpeg' ? 0.92 : 1.0);
                    };
                    
                    img.src = URL.createObjectURL(file);
                });
            }

            function compressOnlyImage(file, targetSizeKB = 50) {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = function() {
                        const targetSize = targetSizeKB * 1024;
                        
                        // Use original dimensions for compress-only
                        let width = img.width;
                        let height = img.height;
                        
                        const tryCompress = (w, h, q) => {
                            return new Promise((resolveCompress) => {
                                canvas.width = w;
                                canvas.height = h;
                                ctx.clearRect(0, 0, w, h);
                                
                                // Fill with white background for JPEG (prevents black backgrounds)
                                ctx.fillStyle = '#FFFFFF';
                                ctx.fillRect(0, 0, w, h);
                                
                                ctx.drawImage(img, 0, 0, w, h);
                                
                                canvas.toBlob((blob) => {
                                    resolveCompress({
                                        blob: blob,
                                        size: blob.size,
                                        width: w,
                                        height: h,
                                        quality: q
                                    });
                                }, 'image/jpeg', q);
                            });
                        };
                        
                        const findOptimalSettings = async () => {
                            let bestResult = null;
                            
                            for (let scale = 1.0; scale >= 0.3; scale -= 0.1) {
                                const testWidth = Math.floor(width * scale);
                                const testHeight = Math.floor(height * scale);
                                
                                let minQ = 0.1;
                                let maxQ = 0.95;
                                let attempts = 0;
                                
                                while (maxQ - minQ > 0.05 && attempts < 10) {
                                    const testQ = (minQ + maxQ) / 2;
                                    const result = await tryCompress(testWidth, testHeight, testQ);
                                    
                                    if (result.size <= targetSize) {
                                        bestResult = result;
                                        minQ = testQ;
                                    } else {
                                        maxQ = testQ;
                                    }
                                    attempts++;
                                }
                                
                                if (bestResult && bestResult.size <= targetSize) {
                                    break;
                                }
                            }
                            
                            if (!bestResult) {
                                bestResult = await tryCompress(
                                    Math.floor(width * 0.3),
                                    Math.floor(height * 0.3),
                                    0.1
                                );
                            }
                            
                            resolve({
                                blob: bestResult.blob,
                                name: getOutputFilename(file.name, file.type, 'compress'),
                                originalSize: file.size,
                                newSize: bestResult.size,
                                width: bestResult.width,
                                height: bestResult.height,
                                quality: bestResult.quality,
                                originalFormat: file.type,
                                newFormat: 'image/jpeg',
                                compressionRatio: ((file.size - bestResult.size) / file.size * 100).toFixed(1),
                                resizedFromOriginal: bestResult.width !== img.width || bestResult.height !== img.height
                            });
                        };
                        
                        findOptimalSettings();
                    };
                    
                    img.src = URL.createObjectURL(file);
                });
            }

            function resizeAndCompressImage(file, maxSize = 500, targetSizeKB = 50) {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = function() {
                        const targetSize = targetSizeKB * 1024; // Convert to bytes
                        
                        // First, calculate dimensions for 500px max side
                        let width = img.width;
                        let height = img.height;
                        
                        if (width > height) {
                            if (width > maxSize) {
                                height = (height * maxSize) / width;
                                width = maxSize;
                            }
                        } else {
                            if (height > maxSize) {
                                width = (width * maxSize) / height;
                                height = maxSize;
                            }
                        }
                        
                        // Function to try compression with current settings
                        const tryCompress = (w, h, q) => {
                            return new Promise((resolveCompress) => {
                                canvas.width = w;
                                canvas.height = h;
                                ctx.clearRect(0, 0, w, h);
                                
                                // Fill with white background for JPEG (prevents black backgrounds)
                                ctx.fillStyle = '#FFFFFF';
                                ctx.fillRect(0, 0, w, h);
                                
                                ctx.drawImage(img, 0, 0, w, h);
                                
                                canvas.toBlob((blob) => {
                                    resolveCompress({
                                        blob: blob,
                                        size: blob.size,
                                        width: w,
                                        height: h,
                                        quality: q
                                    });
                                }, 'image/jpeg', q);
                            });
                        };
                        
                        // Find optimal compression settings
                        const findOptimalSettings = async () => {
                            let bestResult = null;
                            
                            // Start with the resized dimensions and try different scales/qualities
                            for (let scale = 1.0; scale >= 0.3; scale -= 0.1) {
                                const testWidth = Math.floor(width * scale);
                                const testHeight = Math.floor(height * scale);
                                
                                // Binary search for quality at this scale
                                let minQ = 0.1;
                                let maxQ = 0.95;
                                let attempts = 0;
                                
                                while (maxQ - minQ > 0.05 && attempts < 10) {
                                    const testQ = (minQ + maxQ) / 2;
                                    const result = await tryCompress(testWidth, testHeight, testQ);
                                    
                                    if (result.size <= targetSize) {
                                        bestResult = result;
                                        minQ = testQ;
                                    } else {
                                        maxQ = testQ;
                                    }
                                    attempts++;
                                }
                                
                                // If we found a good result at this scale, we can stop
                                if (bestResult && bestResult.size <= targetSize) {
                                    break;
                                }
                            }
                            
                            // If still no good result, use the most compressed version
                            if (!bestResult) {
                                bestResult = await tryCompress(
                                    Math.floor(width * 0.3),
                                    Math.floor(height * 0.3),
                                    0.1
                                );
                            }
                            
                            resolve({
                                blob: bestResult.blob,
                                name: getOutputFilename(file.name, file.type, 'optimize'),
                                originalSize: file.size,
                                newSize: bestResult.size,
                                width: bestResult.width,
                                height: bestResult.height,
                                quality: bestResult.quality,
                                originalFormat: file.type,
                                newFormat: 'image/jpeg',
                                compressionRatio: ((file.size - bestResult.size) / file.size * 100).toFixed(1),
                                resizedFromOriginal: width !== img.width || height !== img.height
                            });
                        };
                        
                        findOptimalSettings();
                    };
                    
                    img.src = URL.createObjectURL(file);
                });
            }

            async function processImages(mode) {
                // Disable all buttons and show progress
                [resizeBtn, compressBtn, combineBtn].forEach(btn => {
                    btn.disabled = true;
                    btn.textContent = 'Processing...';
                });
                
                progressBar.style.display = 'block';
                processedImages = [];
                
                try {
                    for (let i = 0; i < selectedFiles.length; i++) {
                        const file = selectedFiles[i];
                        showStatus(`Processing ${file.name}... (${i + 1}/${selectedFiles.length})`, 'info');
                        
                        let processedImage;
                        if (mode === 'resize') {
                            processedImage = await resizeOnlyImage(file);
                        } else if (mode === 'compress') {
                            processedImage = await compressOnlyImage(file);
                        } else if (mode === 'combine') {
                            processedImage = await resizeAndCompressImage(file);
                        }
                        
                        processedImages.push(processedImage);
                        
                        const progress = ((i + 1) / selectedFiles.length) * 100;
                        updateProgress(progress);
                    }
                    
                    const modeText = mode === 'resize' ? 'resized' : mode === 'compress' ? 'compressed' : 'optimized';
                    showStatus(`Successfully ${modeText} ${processedImages.length} images!`, 'success');
                    createDownloadLinks(processedImages, mode);
                    
                } catch (error) {
                    showStatus(`Error processing images: ${error.message}`, 'error');
                } finally {
                    // Re-enable buttons with original text
                    resizeBtn.disabled = false;
                    resizeBtn.textContent = 'Resize Only';
                    compressBtn.disabled = false;
                    compressBtn.textContent = 'Compress Only';
                    combineBtn.disabled = false;
                    combineBtn.textContent = 'Resize & Compress';
                    progressBar.style.display = 'none';
                }
            }

            function createDownloadLinks(images = processedImages, mode = 'optimized') {
                downloadLinks.innerHTML = '';
                downloadArea.style.display = 'block';
                
                // Add info about the processing results
                const infoDiv = document.createElement('div');
                infoDiv.style.marginBottom = '15px';
                infoDiv.style.padding = '10px';
                infoDiv.style.borderRadius = '5px';
                
                const avgSize = images.reduce((sum, img) => sum + img.newSize, 0) / images.length / 1024;
                const avgCompression = images.reduce((sum, img) => sum + parseFloat(img.compressionRatio), 0) / images.length;
                
                if (mode === 'resize') {
                    infoDiv.style.backgroundColor = '#e3f2fd';
                    infoDiv.style.border = '1px solid #2196F3';
                    const resizedCount = images.filter(img => img.resizedFromOriginal).length;
                    const formatCounts = {};
                    images.forEach(img => {
                        const format = img.newFormat ? img.newFormat.split('/')[1].toUpperCase() : 'Unknown';
                        formatCounts[format] = (formatCounts[format] || 0) + 1;
                    });
                    const formatText = Object.entries(formatCounts).map(([format, count]) => `${count} ${format}`).join(', ');
                    infoDiv.innerHTML = `
                        <strong>Resize Results:</strong><br>
                        Average file size: ${avgSize.toFixed(1)}kB | ${resizedCount} images resized to 500px max<br>
                        <small>Output formats: ${formatText} | Original filenames preserved</small>
                    `;
                } else if (mode === 'compress') {
                    infoDiv.style.backgroundColor = '#f3e5f5';
                    infoDiv.style.border = '1px solid #9C27B0';
                    infoDiv.innerHTML = `
                        <strong>Compression Results:</strong><br>
                        Average file size: ${avgSize.toFixed(1)}kB | Average compression: ${avgCompression.toFixed(1)}%<br>
                        <small>Images converted to JPEG format for optimal compression | Original filenames preserved</small>
                    `;
                } else {
                    infoDiv.style.backgroundColor = '#e8f5e8';
                    infoDiv.style.border = '1px solid #4CAF50';
                    const resizedCount = images.filter(img => img.resizedFromOriginal).length;
                    infoDiv.innerHTML = `
                        <strong>Optimization Results:</strong><br>
                        Average file size: ${avgSize.toFixed(1)}kB | Average compression: ${avgCompression.toFixed(1)}%<br>
                        ${resizedCount} images resized to 500px max | All converted to JPEG format<br>
                        <small>Combined resize & compression for optimal results | Original filenames preserved</small>
                    `;
                }
                downloadLinks.appendChild(infoDiv);
                
                // Individual download buttons
                images.forEach((img, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'download-btn';
                    const sizeKB = (img.newSize / 1024).toFixed(1);
                    btn.textContent = `Download ${img.name} (${sizeKB}kB)`;
                    btn.onclick = () => downloadImage(img);
                    downloadLinks.appendChild(btn);
                });
                
                // ZIP download button
                const zipBtn = document.createElement('button');
                zipBtn.className = 'download-btn';
                const color = mode === 'resize' ? '#2196F3' : mode === 'compress' ? '#9C27B0' : '#4CAF50';
                const hoverColor = mode === 'resize' ? '#1976D2' : mode === 'compress' ? '#7B1FA2' : '#45a049';
                zipBtn.style.backgroundColor = color;
                const zipText = mode === 'resize' ? 'Resized' : mode === 'compress' ? 'Compressed' : 'Optimized';
                zipBtn.textContent = `Download All ${zipText} as ZIP`;
                zipBtn.onmouseover = () => zipBtn.style.backgroundColor = hoverColor;
                zipBtn.onmouseout = () => zipBtn.style.backgroundColor = color;
                zipBtn.onclick = () => downloadAsZip(images, mode);
                downloadLinks.appendChild(zipBtn);
            }

            function downloadImage(img) {
                const url = URL.createObjectURL(img.blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = img.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async function downloadAsZip(images = processedImages, mode = 'optimized') {
                const zip = new JSZip();
                const folderName = mode === 'resize' ? 'resized_images' : mode === 'compress' ? 'compressed_images' : 'optimized_images';
                const folder = zip.folder(folderName);
                
                images.forEach((img) => {
                    folder.file(img.name, img.blob);
                });
                
                try {
                    const content = await zip.generateAsync({type: "blob"});
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${folderName}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    showStatus(`Error creating ZIP: ${error.message}`, 'error');
                }
            }

            // Event listeners for the process buttons
            resizeBtn.addEventListener('click', () => processImages('resize'));
            compressBtn.addEventListener('click', () => processImages('compress'));
            combineBtn.addEventListener('click', () => processImages('combine'));
        </script>
    </body>
</html>
